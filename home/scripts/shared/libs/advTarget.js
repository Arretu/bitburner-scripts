/** @param {NS} ns */
export async function advTarget(ns, mode) {

	let player = ns.getPlayer();
	//let mode = ns.args[1];
	let best5 = [];
	let currTargets = [];

	//List of hosts with money > 0 and root access generated by parseDaemon.
	const possibleTargets = ns.read("/data/possibletargets.txt").split(",");

	for (const target of possibleTargets) {

		if (player.skills.hacking > ns.getServerRequiredHackingLevel(target)) {

			let serverInfo = ns.getServer(target);
			serverInfo.hackDifficulty = ns.getServerMinSecurityLevel(target);
			serverInfo.moneyAvailable = ns.getServerMaxMoney(target);

			let hackChance = ns.formulas.hacking.hackChance(serverInfo, player);
			if (hackChance > 0.9) {

				//Hacking Analysis
				let hackPercent = ns.formulas.hacking.hackPercent(serverInfo, player);
				let hackThreadsNeeded = Math.floor(50 / hackPercent);

				//Debug
				//ns.tprint("DEBUG: ",serverInfo.hostname, " requires ", hackThreadsNeeded, " hacking threads for 50% money");

				let hackSecGain = ns.hackAnalyzeSecurity(hackThreadsNeeded, serverInfo.hostname);
				//ns.tprint(hackSecGain, " hack sec gain")

				let hackValue = serverInfo.moneyMax / 2;

				//Growth Analysis
				serverInfo.moneyAvailable = (serverInfo.moneyMax / 2);

				//ns.tprint("DEBUG ", serverInfo.hostname, " has ", serverInfo.moneyAvailable, " of ", serverInfo.moneyMax, " cash.");

				let growThreadsNeeded = Math.ceil(ns.formulas.hacking.growThreads(serverInfo, player, serverInfo.moneyMax));

				//ns.tprint("DEBUG ", serverInfo.hostname, " needs ", growThreadsNeeded, " grow threads to recover fully");

				let growSecGain = ns.growthAnalyzeSecurity(growThreadsNeeded, serverInfo.hostname);
				//ns.tprint(growSecGain, " grow security gain");

				//Pick the larger of hack sec gain and grow sec gain.
				let sumSecGain = hackSecGain + growSecGain;

				//ns.tprint("DEBUG: ",sumSecGain, " total sec gain")

				//Weaken Analysis
				serverInfo.hackDifficulty = serverInfo.minDifficulty + sumSecGain;
				let tWeakenTime = (ns.getWeakenTime(serverInfo.hostname) / 1000);
				let weakenStrength = ns.weakenAnalyze(1);
				let weakenThreads = sumSecGain / weakenStrength;
				//ns.tprint("DEBUG ", serverInfo.hostname, " needs ", weakenThreads, " weaken threads in ", tWeakenTime," seconds");

				//Lets do some maths? Wtf is going on.
				let targetScore = (hackValue / tWeakenTime);

				//Debug
				//ns.tprint(target);
				//ns.tprint("DEBUG: ",serverInfo.hostname, " generates ", targetScore, "$/s");

				const thisTarget = [target, targetScore];
				currTargets.push(thisTarget);

				//Debug
				//ns.tprint("from curr targ", currTargets.toString());
				//ns.tprint(serverInfo.hostname," yields ", hackValue, " money in ", tWeakenTime, " seconds with",growThreadsNeeded," ", hackThreadsNeeded ," g w threads ",);
				//ns.tprint(growSecGain, " grow sec gain ", hackSecGain, " hack sec gain.")
			}
		}
	}

	//sort list by highest score
	currTargets.sort(function (a, b) { return b[1] - a[1]; });


	//Push top 5 hostnames to new array
	for (let i = 0; i <= 3; i++) {
		best5.push(currTargets[i][0]);
	}

	//ns.tprint("Debug: Mode is: ", mode);
	if (mode == "w") {
		if (ns.fileExists("/data/currtargets.txt", "home") == true) {
			ns.mv("home", "/data/currtargets.txt", "/data/old/currtargets.txt");
		}
		ns.print("Top 5 Targets: ",best5.toString());
		ns.write("/data/currtargets.txt", best5.toString());
		return best5;
	} else {
		return best5;
	}
}